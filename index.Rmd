---
title: "Statistiline modelleerimine 2017"
date: "`r format(Sys.time(), '%d-%m-%Y')`"
author: "Märten Veskimäe & Mihkel Solvak"
output:
  prettydoc::html_pretty:
    theme: cayman
    toc: true
    toc_depth: 2
    # toc_float: true
    # code_folding: show
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T,
                      warning = F,
                      message = F,
                      comment = NA,
                      fig.align="center")
Sys.setlocale("LC_ALL", "UTF-8")
```

<style>
.tip{
  background-color:rgba(204,229,255,0.5);
  text-align:left;
  color:rgb(0,102,204);
  vertical-align: middle;
  padding:40px 0; 
  margin-top:10px;
  border-radius: 5px;
  border: 1px solid rgba(204,229,255,0.7);
}
.tip a{
  color:rgb(0,51,102);
}
</style>

# Sissejuhatus R keelde

## Teaser
- <a href="https://martenveskimae.github.io/stat-mod/rahalised_annetused.html">Rahalised annetused erakondadele</a>

### Paketid

```{r}
library(tidyverse)
library(ggthemes)
```

## Taustaks

R on statistikale ja andmete visualiseerimisele suunatud vabavaraline programmeerimiskeel. R loodi 90ndate alguses S-i baasile ning on tasapisi muutunud üheks enimkasutatavaks statistika tarkvaraks.

![R Passes SPSS in Scholarly Use, Stata Growing Rapidly](images/software.png)
<a href="http://r4stats.com/2014/08/20/r-passes-spss-in-scholarly-use-stata-growing-rapidly/">R Passes SPSS in Scholarly Use, Stata Growing Rapidly (2014)</a>

R-il on olulisi eeliseid mitmete teiste statistikatarkvarade ees:

- R on eeskätt programmeerimiskeel, mis tähendab, et see võimaldab luua uusi funktsioone vastavalt eesseisvale probleemile;
- R on vabavaraline ning kasvava populaarsusega, mis tähendab, et uute meetodid jõuavad R-i kasutajateni enne teisi;
- R jookseb kõikidel levinud OS-idel ning on tasuta kättesaadav;
- R ühildub mitmete teiste keeltega, mis teeb selle laiemalt kasutatavaks (näiteks käesolev **markdown-i** dokument);
- R pakub visualiseerimisel tõenäoliselt parimat tasakaalu lihtsuse ja esteetilisuse vahel;
- R on tõenäoliselt üks parimaid vahendeid statistika tegemiseks ka aastakümne pärast, mis tähendab, et selle õppimiseks kulutatud aeg pole raisatud.

Sellega seoses on sel ka miinuseid:

- nõuab uue keele õppimist, mis võib olla alguses keeruline;
- aeg ajalt esineb uuemates pakettides vigu, mis tähendab, et tuleb olla tähelepanelik;
- seab kõrgemad nõuded meetodite tundmisele.

## Kasulikud lingid

Nädal 1:

- <a href="http://dplyr.tidyverse.org">Grammar of Data Manipulation • dplyr</a>
- <a href="http://ggplot2.tidyverse.org">Elegant Data Visualisations Using the Grammar of Graphics • ggplot2</a>
- <a href="http://www.statmethods.net/input/dates.html">Date Values</a>
- <a href="https://www.tutorialspoint.com/r/r_operators.htm">R - Operators</a>
- <a href="http://rmarkdown.rstudio.com/lesson-1.html">R Markdown</a>

Nädal 2:

- <a href="https://www.datacamp.com/community/tutorials/r-tutorial-apply-family#gs.oydmaoU">Tutorial on the R Apply Family</a>
- <a href="http://seananderson.ca/2013/10/19/reshape.html">An Introduction to reshape2</a>

Nädal 3:

- <a href="https://en.wikipedia.org/wiki/Bootstrapping_(statistics)">Bootstrapping</a>

Huvitavat:

- <a href="https://www.youtube.com/watch?v=jk9S3RTAl38&ab_channel=StatisticalLearning">John Chambers, S-i looja (intervjuu)</a>

## Installeerimiseks

R-i kasutamiseks piisab vaid R-i "mootori" installeerimisest, kuid mugavam on kasutada graafilist kasutajaliidest, näiteks R-Studiot.

- <a href="https://www.r-project.org">R</a></br>
- <a href="https://www.rstudio.com/products/rstudio/">R studio (GUI)</a>

Kuna R on vabavaraline tarkvara, siis on mitmete R-i funktsioonide kasutamiseks vajalik need esmalt alla laadida. See toimub R-i keskkonnas `install.packages(...)` abil (nt `install.packages("tidyverse")`), mispuhul **pakett** on funktsioonide kogum. Vajaminevate pakettide peale hetkel mõtlema ei pea, need tulevad jooksvalt praktikumide käigus.

## Kui satud hätta..

R-i pakettidel on enamasti küllatki hästi lahti kirjutatud **help** sektsioon, mis on leitav help tabi alt (enamasti paremal all nurgas). Help tabi otsingusse saab kirjutada otsitud funktsiooni nime, misjärel ta kuvab ta funktsiooni kirjelduse ning argumentide väärtused. Enamasti on lisatud mõned näited funktsiooni kasutamisvõimalustest. Võimalik on veel:

- kirjutada konsooli ?funktsiooni nimi (nt `?read.csv()`) või `help(...)`, kuhu läheb argumendiks funktsiooni nimi;
- selekteerida funktsioon ja vajutada klaviatuuril F1.

Lisaks R-is olemasolevale kirjeldusele on mitmed paketid avaldatud teadusajakirjades, eeskätt ajakirjas <a href="https://www.jstatsoft.org/index">Journal of Statistical Software</a>. Samuti on enamus tüüp-probleemid lahendatud <a href="https://stackoverflow.com">Stack Overflow</a> lehel. Mõlemal juhul peaks google viima sobiva lahenduseni.

## Tööpõhimõtted
### Objektid

R-i põhiline töövahend on **objekt**, mis võib sisaldada nii funktsioone kui andmeid. Objekte saab ise luua `<-` või `=` märkide abil (`<-` on mõnevõrra kindlam meetod ja mõned soovitavad kasutada seda. Üldjuhul, sh selle aine raames, piisab ka `=` kasutamisest).

```{r}
x = 5
x
```

Kui soovime siduda rohkem andmeid ühe objektiga, on võimalik luua **vektor** (jada / ühedimensionaalne maatriks).
```{r}
x <- c(5, 12.3, 3:10)
x
```

Objekt võib saada sisendi ka teisest objektidest. Samuti võib teha objektidega tehteid.
```{r}
y = x - 5
y
```

Objektiks võib olla ka funktsioon.
```{r}
lahuta.viis = function(x){
  tmp = x - 5
  return(tmp)
}

y = lahuta.viis(x)
y
```

### Põhilised andmetüübid

Numbrid:
```{r}
x = 1
str(x)
```

Tähemärgid (numbrid muudetakse tähemärkideks):
```{r}
x = c("a", "b", 1, 2)
str(x)
```

Faktorid (identsed elemendid saavad sama koodi):
```{r}
x = as.factor(c("a", "b", "1", "2", "a", "2"))
str(x)
```

Kuupäevad:
```{r}
x = as.Date("2017-09-01")
str(x)
```

Kuupäevade puhul on oluline jälgida formaati. Vaikimisi on selleks **yyyy-mm-dd**, kuid kui sisse loetavad andmed on teises formaadis, tuleks see `as.Date(...)` käskluses täpsustada `format` või `origin` argumentidega. Formaatidest pikemalt: <a href="http://www.statmethods.net/input/dates.html">Date Values</a>.

```{r}
as.Date("01-09-2017", format="%d-%m-%Y")
as.Date(17410, origin="1970-01-01")
```

### Andmetabelid

Seni vaadatud jadad on olnud kõik ühedimensionaalsed, ent andmed võivad olla ka mitmedimensionaalsed. Enimlevinud mitmedimensionaalsed formaadid on **andmetabelid** ja **maatriksid**, millest peamiselt keskendume esimesele. Maatriks on kahedimensionaalne vektor, mis on justkui mitu vektorit kokku liidetuna, kuid kõik vektorid peavad olema sama liiki andmetega.

```{r}
matrix(1:9, nrow=3, byrow = T)
matrix(letters[1:9], nrow=3, byrow = T)
```

Mitu samapikkust vektorit saab liita kokku üheks ka andmetabeliks ehk data frameiks (`data.frame(...)`). Data frame'i erinevus seisneb selles, et veerud võivad sisaldada eritüüpi andmeid (nt üks veerg on numbriline, teine sisaldab faktoreid jne).
```{r}
x = c(1:4)
y = c("Audi", "DAF", "Ford", "GAZ")
z = x-5

df = data.frame(tunnus.1 = x,
                tunnus.2 = y,
                tunnus.3 = z)
df
```

Andmetabelite tunnuseid (ehk veerge) saab kätte ka vektorina kasutades `$` märki:
```{r}
df$tunnus.2
```

Võimalik on kasutada ka indeksi (järjekorra) numbrit kandilistes sulgudes. Andmetabelite puhul on esimene number rea number ning koma järel veeru number. Vektori puhul piisab vaid rea numbrist.
```{r}
df[,2]
df["tunnus.2"]
df[1,]["tunnus.2"]
df[1,2]
df$tunnus.2[2]
```

### Listid

Kõiki erinevaid objekte saab koondada listidesse (`list(...)`). List on hea koondamaks erinevate pikkustega või erineva iseloomuga, kuid samateemalisi andmeid. Tihti võib liste kohata erinevate funktsioonide väljundites.

```{r}
ls = list(df)
ls[[2]] = c(1:10)
ls[[3]] = y[2:4]

ls
```

### Funktsioonid objektide kohta

Kõikide objektide puhul:

- `str(...)` - objekti struktuur
- `typeof(...)` - storage mode
- `is.numeric(...)` - kas on...
- `is.character(...)`
- `is.factor(...)`
- `is.function(...)`
- `is.logical(...)`

...

Vektori puhul:

- `length(...)` - vektori pikkus

Data frame'i puhul:

- `dim(...)` - data frame'i dimensioonid (ridu, veerge)
- `nrow(...)` - ridade arv
- `ncol(...)` - veergude arv

Formaadi muutmiseks:

- `as.vector(...)` - vektor
- `as.matrix(...)` - maatriks
- `as.Date(...)` - kuupäev
- `as.data.frame(...)` - data frame
- `as.list(...)` - list

## Andmestike laadimine

R suudab lugeda sisse enamikke levinud andmefailide formaate, kuid kõige sagedasemalt kasutatakse .csv (*comma separated values*). Andmestike sisse lugemiseks on erinevaid funktsioone, kuid .csv-de puhul piisab `read.csv(...)`. `read.csv(...)` võimaldab muu hulgas määratleda, kuidas on eraldatud erinevad veerud (`sep`; koma, semikooloni vm abil) ja mida kasutatakse komakohtade eraldamiseks (`dec`; punkt, koma vm). See võib olla oluline, kuna erinevad programmid erinevatel OS-idel võivad kasutada erinevaid standardeid.

### Internetist

```{r}
url = "https://martenveskimae.github.io/stat-mod/party_dataset.csv"
df = read.csv(url)
```

Andmestiku vaatamiseks võib küsida tervet andmestikku, aga võib ka küsida esimesi või viimaseid ridu. Selleks saab kasutada nii indeksi kui ka eraldi funktsioone `head(...)` ja `tail(...)`.

```{r}
df[1:6, 1:4]

head(df[,1:4])
tail(df[,1:4])
```

Et näha, millised tunnused andmestikus on, võib küsida tunnuste pealkirju `colnames(...)` funktsiooiga.

```{r}
colnames(df)
```

### Kohalikult kettalt

Kohalikult kettalt andmestike laadimiseks tuleb märkida ära andmestiku asukoht kettal. Selle lihtsustamiseks on otstarbekas märkida ära töökeskonna asukoht.

Olemasoleva asukoha nägemiseks on funktsioon `getwd()`.
```{r}
getwd()
```

Kui tahta seda muuta, saab kasutada `setwd(...)` funktsiooni, kus argumendiks on soovitud uus asukoht.

## Andmetega tutvumine

Kokkuvõtvaid andmed nii andmetabelite kui teiste andmeformaatide kohta näeb funktsiooniga `summary(...)`.
```{r}
summary(df)
```

Faktortunnuste puhul võib pakkuda huvi, millised erinevad kategooriad on andmestikus esindatud. Näiteks võime vaadata, millised erakonnad andmestikus leiduvad.
```{r}
levels(df$party)
```

Kui soovida täpsemat ülevaadet, näiteks, mitu andmepunkti on iga erakonnaga seotud, siis selleks on hea kasutada paketti **tidyverse**. Tidyverse hõlmab endas mitmeid erinevaid, kuid omavahel ühilduvaid pakette. Üks neist, **dplyr**, pakub mitmeid funktsioone andmete mugavaks töötlemiseks (eeskätt filtreerimine, grupeerimine, tunnuste muutmine jne). Teine oluline eelis tuleneb paketist **magrittr**, mis võimaldab käsklusi sisestada jadana (ing.k *pipe*). See kiirendab tööprotsessi ja muudab R-i koodi kergemini jälgitavaks. Pipe'ide kasutamiseks tuleb kahe funktsiooni vahel lisada `%>%` sümbolid. Enne näite juurde liikumist on vajalik tidyverse aktiveerida, milleks on funktsioon `library(...)`.

```{r}
library(tidyverse)
```

Pipe'i näide võib olla järgnev:
```{r}
c(1:10) %>% lahuta.viis()
```

Järgnevalt tutvume, mitu rida on seotud üksikute erakondadega (sagedustabel). 
```{r}
df %>%
  group_by(party) %>%
  summarize(n = n())
```

**dplyr** kohta leiab rohkem informatsiooni siit: <a href="http://dplyr.tidyverse.org">Grammar of Data Manipulation • dplyr</a>

## Filtreerimine & joonised 

Kõige kiirem viis andmete visualiseerimiseks on kasutada funktsioone `plot(...)` või `hist(...)`, kus tuleb määratleda telje/telgede väärtused.

```{r}
plot(df$year, df$support)
```

```{r}
hist(df$support)
```

Paraku ei ole antud funktsioonid väga mugavad tidyverse'is kasutamiseks ning kujunduse muutmine on piiratud võimalustega. Kõige enim levinud viis andmete visualiseerimiseks R-i keskkonnas on paketiga **ggplot2**, mis on samuti tidyverse'i osa.

```{r}
df %>%
  filter(party=="ref") %>%
  ggplot() +
  geom_point(aes(year, support))
```

```{r}
df %>%
  filter(party=="ref") %>%
  ggplot() +
  geom_histogram(aes(support))
```

<div class="tip">
**Võrdlusoperaatorid**

Filtreerimisel või muude võrdluste tegemisel kasutatakse teatud tingmärke, mida nimetatakse võrldusoperaatoriteks. R-is on need järnevad:

Operaator   | Tulemus
----------- | -----------
`==`        | Võrdne
`!=`        | Mittevõrdne
`>`         | Suurem
`<`         | Väiksem
`>=`        | Suurem-võrdne
`<=`        | Väiksem-võrdne
`%in%`      | Sisaldab

**Loogilised operaatorid**

Olukordades, kus soovime mitut võrdlust/tingimust kombineerida, tuleb erinevad komponendid siduda omavahel loogiliste operaatoritega:

Operaator   | Tulemus
----------- | -------------------------------------------------------------------------------------------------------------
`&`         | Loogiline JA üksikute vektori komponentide kohta (väljund on TRUE/FALSE kõigi vektori komponentide kohta)
`&&`        | Loogiline JA kõigi vektori komponentide kohta (väljund on ainult üks TRUE/FALSE kogu vektori kohta)
`|`         | Loogiline VÕI üksikute vektori komponentide kohta (väljund on TRUE/FALSE kõigi vektori komponentide kohta)
`||`        | Loogiline VÕI kõigi vektori komponentide kohta (väljund on ainult üks TRUE/FALSE kogu vektori kohta)
`!`         | Loogiline mittesamaväärsus


Näiteid: <a href="https://www.tutorialspoint.com/r/r_operators.htm">R - Operators</a>
</div>

Kujunduse kiireks muutmiseks on erinevad valmislahendused, mis on kättesaadavad **ggthemes** paketiga.
```{r}
library(ggthemes)

df %>%
  filter(party=="ref") %>%
  ggplot() +
  geom_point(aes(year, support)) +
  theme_bw()
```

**ggplot2** kohta leiab rohkem informatsiooni siit: <a href="http://ggplot2.tidyverse.org">Elegant Data Visualisations Using the Grammar of Graphics</a>

# Jaotus ja keskmised

### Paketid

```{r}
library(tidyverse)
library(ggthemes)
library(e1071)
library(reshape2)
```

### Andmestik

```{r}
df = read.csv("https://martenveskimae.github.io/stat-mod/party_dataset.csv")
```

## Histogramm
Vaatame jaotuste järsakust ja sümmeetrilisust visuaalselt histogrammi abil. `geom_histogram(...)` annab vaikimisi sagedusjaotuse, kuid on võimalik valida ka protsente või tõenäosustihedust.

```{r}
df %>%
  ggplot() +
  geom_histogram(aes(support, ..count../sum(..count..))) +
  geom_line(aes(support, ..density../100), stat = "density") +
  scale_y_continuous(labels=scales::percent) +
  scale_x_continuous(labels=scales::percent) +
  labs(y="protsent") +
  theme_bw()
```

**ggplot** võimaldab luua eraldi joonised erinevate gruppide jaoks kasutades `facet_wrap(...)` käsklust.

```{r}
df %>%
  ggplot() +
  geom_histogram(aes(support, ..count../sum(..count..))) +
  geom_line(aes(support, ..density../100), stat = "density") +
  facet_wrap(~party) +
  scale_y_continuous(labels=scales::percent) +
  scale_x_continuous(labels=scales::percent) +
  labs(y="protsent") +
  theme_bw()
```

Silmas tuleb pidada, et sel puhul kalkuleerib **ggplot** tulpade laiused ja hulga üle kõikide kuvatud jooniste, mistõttu erinevad need üksikult kuvatud joonistest. Tulpade hulga ja laiuste kontrollimiseks on argumendid `bins` ja `binwidth`, millest esimene määrab tulpade hulga ja teine laiused. Neid käsklusi ei saa korraga kasutada (binwidth kirjutab binsi üle).

```{r}
df %>%
  ggplot() +
  geom_histogram(aes(support, ..count../sum(..count..)), bins=10, binwidth=0.03) +
  geom_line(aes(support, ..density../100), stat = "density") +
  facet_wrap(~party) +
  scale_y_continuous(labels=scales::percent) +
  scale_x_continuous(labels=scales::percent) +
  labs(y="protsent") +
  theme_bw()
```

## Järsakuse- ja assümmeetriakordaja

Vaatame järsakust ja sümmeetrilisust ka numbriliselt nn järsakuse- ja assümmeetriakordaja abil. Seda võimaldab pakett **e1071**, kust leiame käsklused `skewness(...)` ja `kurtosis(...)` (rakendatavad valemid on leitavad helpist). Kuna soovime rakendada antud käsklusi kõigi gruppide (erakondade) jaoks eraldi, siis tuleks andmestik esmalt filtreerida grupeerimistunnuse alusel (party) ning alles seejärel rakendada antud käsklusi.

```{r}
df %>%
  group_by(party) %>%
  summarise(skewness = skewness(support, na.rm=T),
            kurtosis = kurtosis(support, na.rm=T))
```

<div class="tip">
Alternatiiv **dplyr** meetodile oleks **for loop**. Loopimine on küll võrdlemisi lihtne, kuid vahel mitte kõige efektiivsem viis:

```{r}
parties = as.character(unique(df$party))
s = c()
k = c()
for(i in 1:length(parties)){
  s[length(s)+1] = skewness(df$support[df$party==parties[i]], na.rm=T)
  k[length(k)+1] = kurtosis(df$support[df$party==parties[i]], na.rm=T)
}
names(s) = parties
names(k) = parties
s;k
```

Sama tulemuse saab efektiivsemalt kasutades `apply(...)` käsklust (antud juhul `sapply(...)`. Rohkem applyst: <a href="https://www.datacamp.com/community/tutorials/r-tutorial-apply-family#gs.oydmaoU">Tutorial on the R Apply Family</a>), mis jäljendab eelneva meetodi loogikat.

```{r}
s = sapply(as.character(unique(df$party)), function(x) skewness(df$support[df$party==x], na.rm=T))
k = sapply(as.character(unique(df$party)), function(x) kurtosis(df$support[df$party==x], na.rm=T))
s;k
```
</div>

## Keskmine, mediaan ja mood

Moodi, ehk kõige sagedamini esineva väärtuse leidmiseks eraldi käsklus puudub, ent seda on lihtne leida sagedustabelist.
```{r}
df %>%
  group_by(party, support) %>%
  summarise(n = n()) %>%
  na.omit() %>%
  group_by(party) %>%
  summarise(mode = support[n==max(n)][1])
```

**dplyri** saab kasutada ka keskmise ja mediaani leidmiseks.
```{r}
df %>%
  group_by(party) %>%
  summarise(mean = mean(support,na.rm=T),
            median = median(support,na.rm=T))
```

Viimaks võib kanda leitud väärtused histogrammile, et neid visuaalselt kõrvutada. Kuigi **ggplot** oskab lisada joonistele funktsioone, ei suuda ta praeguses versioonis kuvada eraldi funktsioone eraldi gruppidele (nt kasutades `facet_wrap(~party)`). Otstarbekas on sellisel juhul teha uus andmetabel keskmiste väärtustega. Andmetabeli mugavamaks kasutamiseks pöörame tabeli *laiast* formaadist *pikka* formaati, kasutades selleks **reshape2** paketti ja `melt(...)` funktsiooni. Rohkem **reshape2** ja laia/pika formaadi kohta: <a href="http://seananderson.ca/2013/10/19/reshape.html">An Introduction to reshape2</a>.

```{r}
keskmised = df %>%
  group_by(party, support) %>%
  summarise(n = n()) %>%
  na.omit() %>%
  group_by(party) %>%
  summarise(keskmine = mean(support),
            mediaan = median(support),
            mood = support[n==max(n)][1]) %>%
  melt("party",c("keskmine", "mediaan", "mood"),"Keskmised")

df %>%
  ggplot() +
  geom_histogram(aes(support)) +
  geom_line(aes(support, ..density..), stat = "density") +
  geom_vline(data=keskmised,aes(xintercept=value, linetype=Keskmised, color=Keskmised)) +
  facet_wrap(~party) +
  scale_x_continuous(labels=scales::percent) +
  theme_bw()
```

<div class="tip">
Lisaks mediaanile võivad huvipakkuvad olla ka teised **protsentiilid** (mediaan on 50 protsentiil), eeskätt 25 ja 75 (teisisõnu I ja III kvartiil). Veel võib aeg-ajalt kohta mõistet **kvartiilhaare** (*interquartile range - IQR*), mis tähistab vahemikku I ja III kvartiili vahel. R-is on protsentiilide leidmiseks käsklus `quantile(...)`.

```{r}
sapply(as.character(unique(df$party)), function(x) quantile(df$support[df$party==x],c(.025,.25,.5,.75,.975),na.rm=T))
```
Eelnevalt toodud protsentiilid saab graafida **boxploti** abil, mis kuvab veel lisaks erindid (*outliers*).

```{r}
df %>%
  ggplot() +
  geom_boxplot(aes(party,support)) +
  scale_y_continuous(labels=scales::percent) +
  theme_bw()
```

</div>
# Usaldusvahemikud

### Paketid

```{r}
library(tidyverse)
library(ggthemes)
library(reshape2)
```

### Andmestik

```{r}
df = read.csv("https://martenveskimae.github.io/stat-mod/party_dataset.csv")
```

## Standardhälve

Eelmisest korrast teame, et keskmine toetusprotsent erakonniti erineb, aga erineb ka kõikumine keskmise ümber. Osade erakondade puhul on keskmine toetus stabiilselt ühe tüüpväärtuse ümber, aga teistel mitte. Selle hindamiseks kasutatakse tüüpiliselt *variatsiooni* ja *standardhälvet*, mis on R-is leitav käsklustega `var(...)` ja `sd(...)`. 

<div class="tip">
Variatsioon on *eeldatav* erinevus tõelise väärtuse ja keskmise vahel ruudus:

$Var(X) = E[(X-\mu)^2]$

ehk teisisõnu erinevuste keskmine:

$Var(X) = \frac{ \sum(X-\mu)^2}{N-1}$

```{r}
X = 1:10

var(X)
sum((X - mean(X))^2) / (length(X)-1)
```

(Miks on jagaja $N-1$ ja mitte $N$? Vahe tuleneb sellest, kas meil on andmed kogu populatsiooni kohta või valim populatsioonist, mis on alati väiksem kui N!)

Variatsiooni leidmiseks on erinevused võetud ruutu. Et jõuda tagasi algskaala juurde, tuleks variatsioonist võtta ruutjuur, mis ongi standardhälve:

$\sigma=\sqrt{E[(X-\mu)^2]}$

```{r}
X = 1:10

sqrt(var(X))
sd(X)
```

Standardhälvet võib seega mõista kui keskmist erinevust keskmisest.
</div>

Vaatame erakondade keskmisi ja standardhälvet lähemalt:
```{r}
keskmised = df %>%
  group_by(party) %>%
  summarise(keskmine = mean(support, na.rm=T),
            s.ylemine = keskmine + sd(support, na.rm=T),
            s.alumine = keskmine - sd(support, na.rm=T)) %>%
  melt("party",c("keskmine", "s.ylemine", "s.alumine"), "Varieeruvus")

df %>%
  ggplot() +
  geom_line(aes(as.Date(date), support)) +
  geom_hline(data=keskmised,aes(yintercept=value, linetype=Varieeruvus, color=Varieeruvus)) +
  facet_wrap(~party) +
  scale_y_continuous(labels=scales::percent) +
  labs(x="") +
  theme_bw()
```

## Standardviga ja usaldusvahemikud

Millest see kõikumine keskmine ümber tuleneb on meile teada. Erakondade toetus varieerub ajas erinevalt ja meie arvutatud keskmine näitab tüüpväärtust üle aja. Siin on aga veel üks aga! Erakonna igakuised toetusnumbrid on ise sammuti üks statistiline hinnang (enamasti saadud umbes 1000se valimiga küsitlusest)! Milline on erakondade tõeline toetus populatsioonis on kindlaks tehtav vaid kogupopulatsiooni küsitledes ja seda me teha ei saa. Sellest tulenevalt on meie küsitlustulemustes alati mingi viga sees. Mida saame teha, on hinnata toetusprotsendi vahemikku, kus tõeline toetusprotsent tõenäoliselt asetseks.

Teoreetiliselt tähendaks see olukorda, kus võtaksime populatsioonist, kus on tegelikud teotused erakondadele, lõpmatu arv juhuvalimeid ja leiaks nende valimite toetusprotsendid. Enamasti oleks tulemus sarnane tegeliku toetusega (mida me ei tea), samas teatud olukordades oleks tulemus ühele või teisele poole väga mööda. Kui me teeks nendelt juhuvalimitelt toetusprotsentide graafi, tuleks see normaaljaotusega graaf: 95% juhtumitest langeks +/-1.96 z-skoori vahele. Sellest tulenevalt saaksime hinnata, millisesse vahemikku jääb tõeline tulemus (95% tõenäosusega).

Praktikas seda teha ei saa, sest küsitlused on kallid. Küll aga on võimalik tuletada usaldusvahemik kasutades selleks **standardviga**. Standardviga kirjeldab, kui lähedal on valimi keskmine populatsiooni keskmisele, kasutades selleks üldjuhul variatsiooni ja valimi suurust. Standardvea leidmiseks on erinevaid meetodeid, sõltuvalt andmete iseloomust. Antud juhul on tegu proportsioonidega (erakonna toetust väljendatakse protsendina populatsioonist), mispuhul kasutame proportsiooni standardviga:

$SE_p = \sqrt{\frac{p(1-p)}{N}}$

kus:

- p on protsent (antud juhul erakonna toetusprotsent)
- N valimi suurus (antud juhul 1000)

Usaldusvahemiku leidmiseks tuleb korrutada standardviga soovitud z-skoori väärtusega (nt 95% usaldusvahemiku leidmiseks on see 1.96) ning liita või lahutada erakonna toetusprotsendist:

$p \pm ci_{95} = p \pm 1.96 \cdot SE$

Kuivõrd tegu on küllalt spetsiifilise küsimusega, siis on otstarbekas teha oma funktsioon.

```{r}
ci.95 = function(p,n=1000,z=1.96){
  y = p + (z*(sqrt(p*(1-p)/n)))
  a = p - (z*(sqrt(p*(1-p)/n)))
  
  tmp = list(y = y,
             a = a)
  return(tmp)
}

df %>%
  mutate(ylemine =  ci.95(support)[["y"]],
         alumine =  ci.95(support)[["a"]]) %>%
  melt(c("party", "date"), c("support", "ylemine", "alumine"),"Toetus") %>%
  ggplot() +
  geom_line(aes(as.Date(date), value, color=Toetus)) +
  facet_wrap(~party) +
  scale_y_continuous(labels=scales::percent) +
  labs(x="",y="protsent") +
  theme_bw()
```

<div class="tip">
Lihtsamaks lugemiseks võime jooned üle siluda.
```{r}
df %>%
  mutate(ylemine =  ci.95(support)[["y"]],
         alumine =  ci.95(support)[["a"]]) %>%
  melt(c("party", "date"), c("support", "ylemine", "alumine"),"Toetus") %>%
  ggplot() +
  geom_smooth(aes(as.Date(date), value, color=Toetus), se=F, method="lm", formula= y~poly(x, 7), size=.7) +
  facet_wrap(~party) +
  scale_y_continuous(labels=scales::percent) +
  labs(x="",y="protsent") +
  theme_bw()
```
</div>

<div class="tip">
Alternatiivne lähenemine eelnevalt kirjeldatud meetodile oleks simuleerida erakondade toetusprotsente <a href="https://en.wikipedia.org/wiki/Bootstrapping_(statistics)">bootstrap</a> meetodil. Bootstrapi idee seisneb olemasolevast valimist juhuslike valimite võtmises ning nende põhjal huvipakkuvate statistikute arvutamises (eeskätt variatsioon ja standardviga).

Kuna antud juhul on tegu proportsioonidega ning me soovime igat üksikut vaatlust eraldi simuleerida, siis võime seda teha mündiviske loogikal. Mündiviske puhul simuleerib R binaarset jaotust, mille keskmine on meie poolt antud ning jaotus on <a href="https://en.wikipedia.org/wiki/Binomial_distribution">binominaalne</a>. Korrates mündiviske katset piisava arvu kordi (antud juhul katsetame 500ga), saame arvutada simulatsiooni standardhälve ja standardvea.

Mündiviske simulatsiooniks kasutame paketti **mosaic** ning funktsioone `do(...)`, `rFlip(...)` ja `confint(...)`. Käesolevas katses: `do(1000)` kordab katset 1000 korda ning `rFlip(party.n,x)` viskab ühes katses münti nii mitu korda, kui palju on erakonnaga seotud vaatlusi, tõenäosusega x. `confint(...)` arvutab simulatsiooni usaldusvahemikud.

```{r, eval=FALSE}
toetus.sim = function(x,party,yleminea.alumine){
  require(mosaic)
  if(is.na(x)) return(NA)
  party.n = nrow(df[df$party==party & !is.na(df$support),])

  tmp = do(1000) * rflip(party.n,x)
  ci = confint(tmp$prop)
  
  if(yleminea.alumine=="y") return(ci[["97.5%"]])
  if(yleminea.alumine=="a") return(ci[["2.5%"]])
}

df %>%
  rowwise() %>%
  mutate(ylemine = toetus.sim(support,party,"y"),
         alumine = toetus.sim(support,party,"a")) %>%
  melt(c("party", "date"), c("support", "ylemine", "alumine"),"Toetus") %>%
  ggplot() +
  geom_smooth(aes(as.Date(date), value, color=Toetus), se=F, method="lm", formula= y~poly(x, 7), size=.7) +
  facet_wrap(~party) +
  scale_y_continuous(labels=scales::percent) +
  labs(x="",y="protsent") +
  theme_bw()
```

```{r, echo=FALSE}
load("sim.Rda")
sim %>%
  melt(c("party", "date"), c("support", "ylemine", "alumine"),"Toetus") %>%
  ggplot() +
  geom_smooth(aes(as.Date(date), value, color=Toetus), se=F, method="lm", formula= y~poly(x, 7), size=.7) +
  facet_wrap(~party) +
  scale_y_continuous(labels=scales::percent) +
  labs(x="",y="protsent") +
  theme_bw()
```

# Keskmiste võrdlus

### Paketid

```{r}
library(tidyverse)
library(ggthemes)
```

### Andmestik

```{r}
df = read.csv("https://martenveskimae.github.io/stat-mod/party_dataset.csv")
paneel = read.csv("https://martenveskimae.github.io/stat-mod/ep2014_paneel.csv")
```

## T-test

Vaatame Eesti poliitika sukka ja saabast ehk Reformierakonda ja Keskerakonda eelmise valimistsükli ajal.

```{r}
df %>%
  filter(party %in% c("ref", "kesk"),
         year>=2011 & year<2015) %>%
  ggplot() +
  geom_point(aes(as.Date(date),support)) +
  facet_wrap(~party) +
  scale_y_continuous(labels=scales::percent) +
  labs(x="") +
  theme_bw()
```

Nende keskmine toetus on antud perioodil:
```{r}
df %>%
  filter(party %in% c("ref", "kesk"),
         year>=2011 & year<2015) %>%
  group_by(party) %>%
  summarise(keskmine = mean(support,na.rm=T))
```

Tekib küsimus, kas Keskerakonna keskmine toetus üldse erineb oluliselt Reformi keskmisest toetusest? Kahe keskmise võrdlemiseks saab kasutada t-testi meetodit (R-is `t.test(...)`), mis hindab, kas kaks keskmist pärinevad samast populatsioonist või on tegu erinevate gruppidega. Lihtsustatult öeldes, võrreldakse t-testis keskmiste erinevust kogu variatsiooniga, ning hinnatakse saadud tulemuse tõenäosust (kas tegu oli tõenäolise või ebatõenäolise tulemusega, ehk statistiliselt oluline või mitte). T-testi eelduseks on, et mõlemad valimid on normaaljaotuslikud ning sarnase variatiivsusega (viimast eeldust on võimalik rikkuda kasutades "robustset" t-testi, kus vabadusastmeid arvutatakse teisel meetodil!; R kasutab vaikimisi robustset versiooni - argument `var.equal = FALSE`).

<div class="tip">
T-statistiku arvutamiseks ühe valimi puhul on valemiks:

$t = \frac{\bar{x} - \mu_o}{s / \sqrt{N}}$

kus

- $\mu_0$ on võrreldav keskmine
- s on valimi standardhälve

..kahe sõltumatu valimi puhul:

$t = \frac{\bar{x_1}-\bar{x_2}}{\sqrt{\frac{s_1^2}{n_1}+\frac{s_2^2}{n_2}}}$

..ja kahe sõltuva valimi puhul:

$t = \frac{\frac{\sum{d}}{N}}{\sqrt{\frac{\sum{d^2}-\frac{(\sum{d^2})}{N}}{N(N-1)}}}$

kus

- d on paaris olevate väärtuste erinevus
- N on paaride arv

Teeme meetodi illustreerimiseks simulatsiooni. Ütleme, et meil on kaks sõltumatut normaaljaotusega vektorit, mõlemad 50 vaatlusega. Arvutame vektorite t-testi tulemused ja kordame katset 1000 korda (iga kord uute andmetega).

```{r}
t.statistikud = replicate(1000, t.test(rnorm(50), rnorm(50))$statistic)
```

Vaatame saadud t-statistikute jaotust visuaalselt
```{r}
ggplot() +
  geom_density(aes(t.statistikud)) +
  theme_bw()
```

Kui meie eeldused peavad paika, siis peaks tulemus lähenema t-jaotusele vabadusastmel 98 (50+50-2). Genereerime t-jaotuse antud vabadusastmetega ja arvutame 95% usaldusvahemikud. T-jaotuse leidmiseks peaksime leidma t-statistikute umbkaudsed otspunktid, näiteks käsklusega `range(...)`, seejärel looma sümmeetrilise (sest t-jaotus on sümmeetriline!) vektori käsklusega `seq(...)` ning arvutama saadud vektori t-jaotusliku tiheduse etteantud vabadusastmete puhul (praegu 98), kasutades käsklust `dt(...)`. Nendest saavad teoreetilise jaotuse x ja y atribuudid. Usaldusvahemike leidmiseks kasutame käsklust `qt(..)`, mis arvutab teoreetilise jaotuse kvantiilid (praegu 0.025 ja 0.975).

Lisame tulemused eelnenud graafile.

```{r}
r = mean(abs(range(t.statistikud)))
x = seq(-r,r,length=100)
y = dt(x,df=98)

a95 = qt(c(.025, .975), df=98)

ggplot() +
  geom_density(aes(t.statistikud,color="simuleeritud t-statistikud")) +
  geom_line(aes(x,y,color="teoreetiline t-jaotus")) +
  geom_vline(xintercept = a95[1]) +
  geom_vline(xintercept = a95[2]) +
  theme_bw()
```

Joonte vahele jäänud tulemused olid statistiliselt ebaolulised ning servadesse sattunud tulemused statistiliselt olulised 95% usaldusnivoo puhul. Võime arvutada, mitu protsenti osutus olulisteks.

```{r}
pc = length(t.statistikud[t.statistikud<=a95[1] | t.statistikud>=a95[2]]) / length(t.statistikud)
pc
```
`r paste0(round(pc*100,2),"%")`. Peaaegu oodatav tulemus!

</div>

### Ühe valimi t-test

Hindame seda esmalt ühe valimi t testiga. Leiame Reformierakonna keskmise toetuse perioodil 2011-2014 ja võrdleme seda keskerakonna toetusega.

```{r}
ref.keskmine = df %>%
  filter(party == "ref",
         year>=2011 & year<2015) %>%
  pull(support) %>%
  na.omit() %>%
  mean()

kesk = df %>%
  filter(party == "kesk",
         year>=2011 & year<2015) %>%
  pull(support) %>%
  na.omit()

t.test(kesk, mu=ref.keskmine)
```

### Kahe sõltumatu valimi t-test

Kas valitsuse ja opositsiooni toetus erineb üldse oluliselt erinevatel ajahetkedel valimistsüklis? Selleks peaksime tegema kahe sõltumatu valimi t-testi. Testime seda esialgu vaid ühel aastal, näiteks 2014.

```{r}
df %>%
  filter(year==2014) %>%
  select(support,gov) %>%
  t.test(support~gov,data=.)
```

<div class="tip">
Vaatame, kuidas t-testi p-väärtus varieerub erinevatel aastatel.

```{r}
plyr::ldply(unique(df$year), function(x){
  data.frame(p.value = df %>%
               filter(year==x) %>%
               select(support,gov) %>%
               t.test(support~gov,data=.) %>%
               .$p.value,
             year = x)
  }) %>%
  ggplot() +
  geom_point(aes(year,p.value)) +
  geom_hline(yintercept = 0.05) +
  scale_x_continuous(breaks=2007:2017) +
  theme_bw()
```

Paneme lisaks kõrvale keskmised toetusnumbrid antud aastatel.

```{r}
df %>%
  group_by(year,gov=as.factor(gov)) %>%
  summarise(support = mean(support,na.rm=T)) %>%
  ggplot() +
  geom_point(aes(year,support,color=gov)) +
  geom_line(aes(year,support,color=gov)) +
  scale_x_continuous(breaks=2007:2017) +
  scale_y_continuous(labels=scales::percent) +
  theme_bw()
```

</div>

### Kahe sõltuva valimi t-test

Kahe sõltuva valimi t-testi erakonnatoetuse andmestikuga teha ei saa, sest meie uuringu disain ei vasta sellele. Selleks avame ühe teise andmestiku, milleks on paneeluuring enne ja pärast 2014.a. EP valimisi.

```{r}
summary(paneel)
```

Vaatame näiteks, kas kurikuulus „Haldermanni case“ avaldas mõju e-valimiste usaldusele (vt näit <a href="http://www.delfi.ee/news/paevauudised/eesti/eksperdid-eesti-e-valimised-on-nii-ebaturvalised-et-tuleks-kohe-ara-lopetada?id=68657131">Eksperdid: Eesti e-valimised on nii ebaturvalised, et tuleks kohe ära lõpetada</a>). Antud asja kajastus levis laiemalt 13. mail selleks ajaks oli paneeluuringu esimeses laines juba piisavalt palju inimesi intervjueeritud, vaatame kas ja kuidas nende usaldus nägi välja enne ja kuidas pärast.

Esimene intervjueerimislaine kestis ka pärast antud juhtumit, mistõttu tuleks sealt välja filtreerida vaatlused pärast 13. maid. Ühtlasi puhastame andmed keeldunud ja puuduvatest väärtustest (kodeeritud 97 ja 98).

```{r}
df2 = paneel %>%
  mutate(submitdate = as.Date(submitdate),
         usaldus.enne = case_when(
           submitdate < as.Date("2014-05-13") & !(Q16_2 %in% c(97:98)) ~ Q16_2),
         usaldus.parast = case_when(
           !(j_reluuring_Q13_2 %in% c(97:98)) ~ j_reluuring_Q13_2)
         )

summary(df2[c("usaldus.enne", "usaldus.parast")])
```

Nüüd saame teha kahe sõltuva valimi t-testi.

```{r}
t.test(df2$usaldus.enne, df2$usaldus.parast, paired=T)
```

# Korrelatsioon
# Lineaarne regressioon
# Logistiline regressioon
